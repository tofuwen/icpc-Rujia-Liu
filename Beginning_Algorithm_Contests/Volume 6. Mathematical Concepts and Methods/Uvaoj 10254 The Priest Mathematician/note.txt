我的解法很好！很正统・・・
但是大数是看了别人的报告提示的，一开始没太弄明白题意・・・
而且知道了大致了数量级，比如用60位之类的・・・・
不过这些东西试试也就出来了吧！
我还是很厉害的！！！


原来还可以找规律啊！！
如果我们设f[i]为4个柱子时把i个东东从一个柱子移到另一个柱子所用的最少步骤，
设g[i]为3个柱子时对应的值，我们可以得到f[n]=min{2*f[k]+g[n-k]}，其中g[i]是已知的为2^i-1。

然后接着就搞不下去了，看了别人报告说要找规律，o(s□t)o。
有了上面的式子之后，我们打印前60个解还是很好打印的，同时把f[i]-f[i-1]也打印出来，
这时会发现f[i]-f[i-1]都是2的某次方，而且2的k次方一共连续出现了k+1次，于是我们就可以以这个特征为依据预处理出所有解了。

思路：
我们先设g[n]表示按照经典的游戏规则（3根柱子），n个盘子最少需要g[n]步，可以知道g[n] = 2^n-1
然后我们再设f[n]表示按照4根柱子的规则来，n个盘子最少需要f[n]步。
那么按照上面步骤可以推出：
1. 把圆盘顶部前k个盘子全部搬到第四根柱子 上 ==》 需要f[k]步
2. 把剩下的n-k个盘子在前3根柱子中按照经典的规则搬到某个柱子上 （假设是a柱） ==》需要g[n-k]步
3. 最后再把那k个盘子搬到目标a柱上 ==》需要f[k]步
所以，f[n] = f[k]*2+g[n-k]
因为f[n]要最小，且k不确定，所以枚举一下k，取最小值即可：
f[n]  =  min{ f[k]*2+g[n-k] , 1<=k<=n }

由于n过大，所以要用到大数。

由于本题的n为10000，上面的算法复杂度为O(n^2)，所以不能用上面方法。

那么就打表找规律一下，并不难找

观察下面前20个，不难找出规律：
[cpp] view plaincopy
f[1] = 1  
----------------  
f[2] = 3,  f[2] = f[1] + 2^1  
f[3] = 5,  f[3] = f[2] + 2^1  
共 2 个 2^1  
----------------  
f[4] = 9,  f[4] = f[3] + 2^2  
f[5] = 13,  f[5] = f[4] + 2^2  
f[6] = 17,  f[6] = f[5] + 2^2  
共 3 个 2^2  
----------------  
f[7] = 25,  f[7] = f[6] + 2^3  
f[8] = 33,  f[8] = f[7] + 2^3  
f[9] = 41,  f[9] = f[8] + 2^3  
f[10] = 49,  f[10] = f[9] + 2^3  
共 4 个 2^3  
----------------  
f[11] = 65,  f[11] = f[10] + 2^4  
f[12] = 81,  f[12] = f[11] + 2^4  
f[13] = 97,  f[13] = f[12] + 2^4  
f[14] = 113,  f[14] = f[13] + 2^4  
f[15] = 129,  f[15] = f[14] + 2^4  
共 5 个 2^4  
----------------  
f[16] = 161,  f[16] = f[15] + 2^5  
f[17] = 193,  f[17] = f[16] + 2^5  
f[18] = 225,  f[18] = f[17] + 2^5  
f[19] = 257,  f[19] = f[18] + 2^5  
f[20] = 289,  f[20] = f[19] + 2^5  
共 6 个 2^5  